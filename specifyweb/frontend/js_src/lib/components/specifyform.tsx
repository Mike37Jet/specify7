/**
 * Renderer for Specify forms
 */

import React from 'react';

import { error } from '../assert';
import type { AnySchema } from '../datamodelutils';
import { f } from '../functools';
import { autoGenerateViewDefinition } from '../generateformdefinitions';
import type { SpecifyResource } from '../legacytypes';
import type { FormMode, FormType, ViewDescription } from '../parseform';
import { getView, parseViewDefinition } from '../parseform';
import type { SpecifyModel } from '../specifymodel';
import { webOnlyViews } from '../webonlyviews';
import { DataEntry } from './basic';
import { useAsyncState, useId } from './hooks';
import { loadingGif } from './queryresultstable';
import { FormCell } from './specifyformcell';
import { hijackBackboneAjax } from '../startapp';
import { Http } from '../ajax';
import { setCurrentView } from '../specifyapp';
import { NotFoundView } from './notfoundview';

/**
 * By default, Specify 7 replaces all ObjectAttachment forms with
 * AttachmentPlugin. To see the original form, render SpecifyForm with
 * viewName=originalAttachmentsView
 */
export const originalAttachmentsView = 'originalObjectAttachment';

/**
 * A hook to get information needed to display a form
 * Can be used independently of <SpecifyForm> if need to get form definition
 * for alternative purposes (i.e a different renderer)
 */
export function useViewDefinition({
  model,
  viewName = model.view,
  formType,
  mode,
}: {
  readonly model: SpecifyModel;
  readonly viewName?: string;
  readonly formType: FormType;
  readonly mode: FormMode;
}): ViewDescription | undefined {
  const [viewDefinition] = useAsyncState<ViewDescription>(
    React.useCallback(
      async () =>
        viewName === 'ObjectAttachment'
          ? {
              ...webOnlyViews().ObjectAttachment,
              model,
              formType,
              mode,
            }
          : getView(
              viewName === originalAttachmentsView
                ? 'ObjectAttachment'
                : viewName
            )
              .then((viewDefinition) =>
                typeof viewDefinition === 'object'
                  ? parseViewDefinition(viewDefinition, formType, mode)
                  : undefined
              )
              .then((viewDefinition) =>
                typeof viewDefinition === 'object'
                  ? viewDefinition.model === model
                    ? viewDefinition
                    : error(
                        'View definition model does not match resource model'
                      )
                  : f.maybe(
                      webOnlyViews()[viewName as keyof typeof webOnlyViews],
                      ({ columns, rows }) => ({
                        columns,
                        rows,
                        formType,
                        mode,
                        model,
                      })
                    ) ?? autoGenerateViewDefinition(model, formType, mode)
              ),
      [viewName, formType, mode, model]
    ),
    false
  );
  return viewDefinition;
}

// TODO: for system tables, display a button to toggle to autogenerated form
/** Renders a form and populates it with data from a resource */
export function SpecifyForm({
  isLoading,
  resource,
  viewName = resource.specifyModel.view,
  formType,
  mode,
  // Don't let view definition overwrite the form type
  forceFormType = false,
}: {
  readonly isLoading?: boolean;
  readonly resource: SpecifyResource<AnySchema>;
  readonly viewName?: string;
  readonly formType: FormType;
  readonly mode: FormMode;
  readonly forceFormType?: boolean;
}): JSX.Element {
  const viewDefinition = useViewDefinition({
    model: resource.specifyModel,
    viewName,
    formType,
    mode,
  });
  const processedDefinition = React.useMemo(
    () =>
      forceFormType && typeof viewDefinition === 'object'
        ? {
            ...viewDefinition,
            formType,
          }
        : viewDefinition,
    [formType, forceFormType, viewDefinition]
  );

  return (
    <RenderForm
      isLoading={isLoading}
      resource={resource}
      viewDefinition={processedDefinition}
    />
  );
}

/**
 * Renders a form from ViewDescription
 * Useful when need to render a hard-coded front-end only form
 */
export function RenderForm<SCHEMA extends AnySchema>({
  isLoading,
  resource,
  viewDefinition,
}: {
  readonly isLoading?: boolean;
  readonly resource: SpecifyResource<SCHEMA>;
  readonly viewDefinition: ViewDescription | undefined;
}): JSX.Element {
  const id = useId(
    `form-${resource.specifyModel.name ?? viewDefinition?.model?.name ?? ''}`
  );
  const oldResourceRef = React.useRef<SpecifyResource<SCHEMA> | undefined>(
    undefined
  );
  React.useEffect(() => {
    oldResourceRef.current = resource;
  }, [resource]);

  const [loadedResource] = useAsyncState(
    React.useCallback(
      async () =>
        hijackBackboneAjax(
          [Http.OK, Http.NOT_FOUND],
          async () => resource.fetch(),
          (status) =>
            status === Http.NOT_FOUND
              ? setCurrentView(new NotFoundView())
              : undefined
        ),
      [resource]
    ),
    false
  );
  const isShowingOldResource =
    typeof loadedResource === 'undefined' &&
    typeof oldResourceRef.current === 'object';
  const resolvedResource = loadedResource ?? oldResourceRef.current;
  const formIsLoaded =
    typeof viewDefinition === 'object' && typeof resolvedResource === 'object';
  const showLoading =
    formIsLoaded && (isLoading === true || isShowingOldResource);
  return (
    <div className={showLoading ? 'relative' : undefined}>
      {showLoading && (
        <div className="top-10 absolute z-10 flex justify-center w-full">
          {loadingGif}
        </div>
      )}
      {formIsLoaded ? (
        <DataEntry.Grid
          viewDefinition={viewDefinition}
          className={showLoading ? 'opacity-50' : undefined}
        >
          {/* Cells are wrapped in rows for debugging purposes only */}
          {viewDefinition.rows.map((cells, index) => (
            <div className="contents" key={index}>
              {cells.map(
                (
                  {
                    colSpan,
                    align,
                    visible,
                    id: cellId,
                    ariaLabel,
                    ...cellData
                  },
                  index
                ) => (
                  <DataEntry.Cell
                    key={index}
                    colSpan={colSpan}
                    align={align}
                    visible={visible}
                    ariaLabel={
                      viewDefinition?.formType === 'formTable'
                        ? undefined
                        : ariaLabel
                    }
                  >
                    <FormCell
                      align={align}
                      resource={resolvedResource}
                      mode={viewDefinition.mode}
                      formType={viewDefinition.formType}
                      cellData={cellData}
                      id={cellId}
                      formatId={id}
                    />
                  </DataEntry.Cell>
                )
              )}
            </div>
          ))}
        </DataEntry.Grid>
      ) : (
        loadingGif
      )}
    </div>
  );
}
